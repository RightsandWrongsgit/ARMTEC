
# SPLIT CONFIGURATION 'EXPORT' AND 'IMPORT'
The easiest way to wrap your mind around configuration is to know that the ACTIVE configuration is what is in your site's database and running your Drupal site.  What doing the 'export' is accomplishing is grabbing the underlying definition of that configuration, tuning it into a whole bunch of YAML files, and putting those files somewhere outside your database. Why you want to think of it in this very basic way is that you could have different versions of your Drupal site with slightly different configurations and you could put the YAML files from those different versions into uniquely named locations.   Where this comes into play is that you have a 'main' (Production) copy of your site but you also have a copy you are working on changes and enhancements, like a 'develop' (Development) version.  Hopefully this begins to clarify how one might do a 'workflow' utilizing a sequence of copies of your website; copies from your individual local developers, individual feature builds, merged development builds, staged testing builds, in addition to 'main'.  

The standard Configuration synchronization in theDrupal Core that we discussed earlier is nice. However, it basically has just the one configuration that is ACTIVE and you are working directly against your Drupal site on any changes as you are doing additional development. You will see this if you use the 'Synchronize' tab and as you work you will see  'New' and 'Changed' section listings of all the stuff you have been doing.  You can move what you are doing in development to active with the synchronization option but you are sort of operating without a safety net of version control.  The Git/GitHub and Platform.sh/Lando approach we set up brings version control in to the picture.   A contributed module called 'Config_Split' then adds the capability to manage different Drupal environments with coordinated but slightly unique configurations.  For example, like we discussed regarding having certain things turned on and off in 'develop', 'staged', and 'main' for the unique goals of how each is used in your workflow.

At this point it may help to clarify that your Platform.sh hosted copies will contain not only the 'main' (Production) environment but also 'staged' and 'develop' environments.  Yet, so to, your Lando containers on your local machine can have these three 'main', 'staged, and 'develop' environments.  In fact, right now we have just created the 'main' environment for your Drupal container instance and a copy of it is on your Platform.sh host and on your Lando local machine.  If you haven't done anything to change the one on your local machine to update it, add or enable different modules, etc. they will be mirror images of each other.  Since we earlier updated our .gitignore file and updated Core and Lando, we also showed how we use the SSH connected relationship and our Git version control commands in GitOps to update hosted 'main' from changes we had made in local 'main'.  Normally we wouldn't be updating 'main' to 'main' but instead do local 'develop' to hosted 'develop' and then merge development code changes into 'staged' and conduct any testing on hosted 'staged' before merging them into hosted 'main' (Production).  If we were in a multi-developer environment or even if we were bored enough to want to jump back and forth between working on different features, we might have generated feature branches off of the 'develop'  environment and then merged upward toward main.

## Summary of the next steps
Later we are going to step through how we bow down to the hosted 'main' as the source of truth and then clone 'staged' from it and clone 'develop' from 'staged'.  We will show how Git is used to do that and how it also works across the hosted and local machine copies of each of these mirrored environments.   But first, lets get set up to allow Drupal to offer coordinated but slightly unique functionality across 'develop', 'staged', and 'main'.  Since the way we are going to use our workflow is to branch these three environments from one another, and we are going to do so right from VSCode on our local machine which will synchronize the same branches on Platform.sh, we want to add the dimension of a machine-environment; that might not be a perfect name for it, but fundamentally just think of it as the fact you have a 'local-develop' as well as a 'hosted-develop' copy of your site.  

We went through how Drupal stores its configuration in a bunch of YAML files.  It keeps one copy in that 'config/sync' directory near the top of that directory map a copy pages back.  Since we are wanting three different configuration versions, we need to store four slightly different copies of the YAML files and make four subdirectories adjacent to that sync location to put them in.

Once we have those subdirectory locations in place we will install and enable the Config_Split module.  After we do that, it will provide an additional menu item under the Administration menu right next to the Configuration Synchronization option that is part of Drupal Core.  In the new menu there are input boxes for you to insert the 'name', 'location', and 'configuration option choices'  for each of the three new configuration versions.  There is also a checkbox for 'active' that tells Drupal which of the configurations to use when and where you want.

Since you are trying to set up a GitOps CI/CD workflow, it isn't any fun having to go in and check which configuration box should be active and inactive each time you are marching through the process.  Therefore, what we will do is put some additional code into the settings.php file with conditional statements telling which configuration should be active in which branch environment. 

If is cool to trigger the active configuration with code in the settings.php file but even more handy is detecting which branch environment we are working in by reading it from Platform.sh's own configuration information.  In Platform.sh what we will be detecting is called <BRANCH_NAME> and that is what will pick up the correct 'main', 'staged', or 'develop' branch name to feed into the conditional code we dropped in to say which configuration is active when.  This should make it clear why there was a whole section title reinforcing "Name consistency".   The name of the configuration subdirectories need to match the name used in the Config_Split menu input to match the name we detect in the <BRANCH_NAME> to match to the conditional code name telling Drupal which is active when.  We will also detect for being on the Lando local copy of the machine-environment and if so, look for any customization of that environment in a /config/local directory. 

Finally, we will also install another Drupal contributed module that basically keeps us from doing something dumb.  Just to make sure you know which branch you are working in at any given point, we will install an indicator to make it obvious; composer require 'drupal/environment_indicator'



[- Next -](../cicd/configsplit2)
